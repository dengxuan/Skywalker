<Project>

    <PropertyGroup>
        <EnablePackageValidation>true</EnablePackageValidation>
        <!-- Don't restore prebuilt packages during sourcebuild. -->
        <DisablePackageBaselineValidation Condition="'$(DotNetBuildFromSource)' == 'true'">true</DisablePackageBaselineValidation>
        <PackageValidationBaselineVersion Condition="'$(PackageValidationBaselineVersion)' == ''">$(NetCoreAppLatestStablePackageBaselineVersion)</PackageValidationBaselineVersion>
        <!-- PackDependsOn is the right hook in a targets file if the NuGet.Build.Tasks.Pack nuget package is used, otherwise
         BeforePack must be used. Setting both to ensure that we are always running before other targets. -->
        <PackDependsOn>AddNETStandardCompatErrorFileForPackaging;IncludeAnalyzersInPackage;$(PackDependsOn)</PackDependsOn>
        <BeforePack>AddNETStandardCompatErrorFileForPackaging;IncludeAnalyzersInPackage;$(BeforePack)</BeforePack>
        <TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);IncludePrivateProjectReferencesWithPackAttributeInPackage</TargetsForTfmSpecificContentInPackage>
        <IncludeBuildOutput Condition="'$(TargetFrameworkSuffix)' != ''">false</IncludeBuildOutput>
        <!-- Don't include target platform specific dependencies, since we use the target platform to represent RIDs instead -->
        <SuppressDependenciesWhenPacking Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(TargetPlatformIdentifier)' != ''">true</SuppressDependenciesWhenPacking>
        <PackageDesignerMarkerFile>$(MSBuildThisFileDirectory)useSharedDesignerContext.txt</PackageDesignerMarkerFile>
        <!-- Generate packages for rid specific projects or for allconfigurations during build. -->
        <!-- A package isn't generated if in servicing or in runtimelab. Intended to be overridden at project level. -->
        <IsRIDSpecificProject Condition="$(MSBuildProjectName.StartsWith('runtime.')) and
                                     !$(MSBuildProjectName.StartsWith('runtime.native'))">true</IsRIDSpecificProject>
        <GeneratePackageOnBuild Condition="('$(BuildAllConfigurations)' == 'true' or
                                       '$(IsRIDSpecificProject)' == 'true') and
                                       '$(PreReleaseVersionLabel)' != 'servicing' and
                                       '$(GitHubRepositoryName)' != 'runtimelab'">true</GeneratePackageOnBuild>
        <!-- Search for the documentation file in the intellisense package and otherwise pick up the generated one. -->
        <LibIntellisenseDocumentationFilePath>$(XmlDocFileRoot)1033\$(AssemblyName).xml</LibIntellisenseDocumentationFilePath>
        <UseIntellisenseDocumentationFile Condition="'$(UseIntellisenseDocumentationFile)' == '' and Exists('$(LibIntellisenseDocumentationFilePath)')">true</UseIntellisenseDocumentationFile>
    </PropertyGroup>

    <Target Name="IncludeAnalyzersInPackage" Condition="'@(AnalyzerReference)' != ''">
        <!-- Call a target in the analyzer project to get all the files it would normally place in a package.
         These will be returned as items with identity pointing to the built file, and PackagePath metadata
         set to their location in the package.  IsSymbol metadata will be set to distinguish symbols. -->
        <MSBuild Projects="@(AnalyzerReference)" Targets="GetAnalyzerPackFiles">
            <Output TaskParameter="TargetOutputs" ItemName="_AnalyzerFile" />
        </MSBuild>

        <ItemGroup>
            <Content Include="@(_AnalyzerFile)" Pack="True" Condition="!%(_AnalyzerFile.IsSymbol)" />
            <!-- Symbols don't honor PackagePath.  By default they are placed in lib/%(TargetFramework).
           Pack does honor TargetPath and does Path.Combine("lib/%(TargetFramework)", "%(TargetPath)"),
           so a rooted path value for TargetPath will override lib.
           https://github.com/NuGet/Home/issues/10860 -->
            <_TargetPathsToSymbols Include="@(_AnalyzerFile)" TargetPath="/%(_AnalyzerFile.PackagePath)" Condition="%(_AnalyzerFile.IsSymbol)" />
        </ItemGroup>
    </Target>

    <PropertyGroup>
        <_MultiTargetRoslynComponentTargetsTemplate>$(MSBuildThisFileDirectory)MultiTargetRoslynComponent.targets.template</_MultiTargetRoslynComponentTargetsTemplate>
        <MultiTargetRoslynComponentTargetsFileIntermediatePath>$(IntermediateOutputPath)MultiTargetRoslynComponent.targets</MultiTargetRoslynComponentTargetsFileIntermediatePath>
        <IncludeMultiTargetRoslynComponentTargets Condition="'$(IncludeMultiTargetRoslynComponentTargets)' == ''">true</IncludeMultiTargetRoslynComponentTargets>
    </PropertyGroup>

    <!-- In packages that contain Analyzers, include a .targets file that will select the correct analyzer. -->
    <Target Name="IncludeMultiTargetRoslynComponentTargetsInPackage" AfterTargets="IncludeAnalyzersInPackage" Condition="'@(AnalyzerReference)' != '' and '$(IncludeMultiTargetRoslynComponentTargets)' == 'true'" DependsOnTargets="GenerateMultiTargetRoslynComponentTargetsFile">
        <ItemGroup>
            <Content Include="$(MultiTargetRoslynComponentTargetsFileIntermediatePath)" PackagePath="build\$(PackageId).targets" Pack="True" />
        </ItemGroup>
    </Target>

    <Target Name="GenerateMultiTargetRoslynComponentTargetsFile" Inputs="$(MSBuildProjectFullPath);_MultiTargetRoslynComponentTargetsTemplate" Outputs="$(MultiTargetRoslynComponentTargetsFileIntermediatePath)">
        <PropertyGroup>
            <_MultiTargetRoslynComponentTargetPrefix>$(PackageId.Replace('.', '_'))</_MultiTargetRoslynComponentTargetPrefix>
            <_MultiTargetRoslynComponentDisableSourceGeneratorPropertyName>Disable$(PackageId.Replace('.', ''))SourceGenerator</_MultiTargetRoslynComponentDisableSourceGeneratorPropertyName>
            <_MultiTargetRoslynComponentDisableSourceGeneratorPropertyName>$(_MultiTargetRoslynComponentDisableSourceGeneratorPropertyName.Replace('Abstractions', ''))</_MultiTargetRoslynComponentDisableSourceGeneratorPropertyName>
        </PropertyGroup>

        <WriteLinesToFile File="$(MultiTargetRoslynComponentTargetsFileIntermediatePath)" Lines="$([System.IO.File]::ReadAllText('$(_MultiTargetRoslynComponentTargetsTemplate)')
                                                 .Replace('{TargetPrefix}', '$(_MultiTargetRoslynComponentTargetPrefix)')
                                                 .Replace('{NuGetPackageId}', '$(PackageId)')
                                                 .Replace('{DisableSourceGeneratorPropertyName}', '$(_MultiTargetRoslynComponentDisableSourceGeneratorPropertyName)'))" Overwrite="true" />
    </Target>

    <!-- Include a netstandard compat error if the project targets both .NETStandard and
       .NETCoreApp. This prohibits users to consume packages on an older .NETCoreApp version
       than the minimum supported one. -->
    <ItemGroup>
        <NETStandardCompatError Include="netcoreapp2.0" Supported="$(NetCoreAppMinimum)" Condition="$(TargetFrameworks.Contains('netstandard2.')) and
                                       ($(TargetFrameworks.Contains('$(NetCoreAppMinimum)')) or $(TargetFrameworks.Contains('$(NetCoreAppCurrent)'))) and
                                       '$(DisableNETStandardCompatErrorForNETCoreApp)' != 'true'" />
        <NETStandardCompatError Include="net461" Supported="$(NetFrameworkMinimum)" Condition="$(TargetFrameworks.Contains('netstandard2.0')) and
                                       ($(TargetFrameworks.Contains('$(NetFrameworkMinimum)')) or $(TargetFrameworks.Contains('net47')) or $(TargetFrameworks.Contains('net48'))) and
                                       '$(DisableNETStandardCompatErrorForNETFramework)' != 'true'" />

    </ItemGroup>

    <!-- Add targets file that marks a .NETStandard applicable tfm as unsupported. -->
    <Target Name="AddNETStandardCompatErrorFileForPackaging" Condition="'@(NETStandardCompatError)' != ''" Inputs="%(NETStandardCompatError.Identity)" Outputs="unused">
        <PropertyGroup>
            <_NETStandardCompatErrorFilePath>$(BaseIntermediateOutputPath)netstandardcompaterrors\%(NETStandardCompatError.Identity)\$(PackageId).targets</_NETStandardCompatErrorFilePath>
            <_NETStandardCompatErrorFileTarget>NETStandardCompatError_$(PackageId.Replace('.', '_'))_$([System.String]::new('%(NETStandardCompatError.Supported)').Replace('.', '_'))</_NETStandardCompatErrorFileTarget>
            <_NETStandardCompatErrorFileContent>
                <![CDATA[<Project InitialTargets="$(_NETStandardCompatErrorFileTarget)">
  <Target Name="$(_NETStandardCompatErrorFileTarget)" Condition="'%24(SuppressTfmSupportBuildWarnings)' == ''">
    <Error Text="$(PackageId) doesn't support %24(TargetFramework). Consider updating your TargetFramework to %(NETStandardCompatError.Supported) or later." />
  </Target>
</Project>]]>
            </_NETStandardCompatErrorFileContent>
        </PropertyGroup>

        <WriteLinesToFile File="$(_NETStandardCompatErrorFilePath)" Lines="$(_NETStandardCompatErrorFileContent)" Overwrite="true" WriteOnlyWhenDifferent="true" />

        <ItemGroup>
            <None Include="$(_NETStandardCompatErrorFilePath)" PackagePath="buildTransitive\%(NETStandardCompatError.Identity)" Pack="true" />
            <None Include="$(PlaceholderFile)" PackagePath="buildTransitive\%(NETStandardCompatError.Supported)" Pack="true" />
            <FileWrites Include="$(_NETStandardCompatErrorFilePath)" />
        </ItemGroup>
    </Target>

    <Target Name="IncludePrivateProjectReferencesWithPackAttributeInPackage" Condition="'@(ProjectReference->WithMetadataValue('PrivateAssets', 'all')->WithMetadataValue('Pack', 'true'))' != ''" DependsOnTargets="BuildOnlySettings;ResolveReferences">
        <ItemGroup>
            <!-- Add ReferenceCopyLocalPaths for ProjectReferences which are flagged as Pack="true" into the package. -->
            <_projectReferenceCopyLocalPaths Include="@(ReferenceCopyLocalPaths->WithMetadataValue('ReferenceSourceTarget', 'ProjectReference')->WithMetadataValue('PrivateAssets', 'all')->WithMetadataValue('Pack', 'true'))" />
            <TfmSpecificPackageFile Include="@(_projectReferenceCopyLocalPaths)" PackagePath="$([MSBuild]::ValueOrDefault('%(ReferenceCopyLocalPaths.PackagePath)', '$(BuildOutputTargetFolder)/$(TargetFramework)'))" />
            <TfmSpecificDebugSymbolsFile Include="@(TfmSpecificPackageFile->WithMetadataValue('Extension', '.pdb'))" TargetPath="/%(TfmSpecificPackageFile.PackagePath)/%(Filename)%(Extension)" TargetFramework="$(TargetFramework)" Condition="'$(IncludeSymbols)' == 'true'" />
            <!-- Remove symbol from the non symbol package. -->
            <TfmSpecificPackageFile Remove="@(TfmSpecificPackageFile->WithMetadataValue('Extension', '.pdb'))" />
            <!-- If the reference assembly is included, don't put the documentation file next to the lib assembly. -->
            <TfmSpecificPackageFile Remove="@(_projectReferenceCopyLocalPaths->WithMetadataValue('Extension', '.xml')->WithMetadataValue('IncludeReferenceAssemblyInPackage', 'true'))" />
        </ItemGroup>

        <ItemGroup>
            <!-- Include the reference assembly and put the documentation file next to it. -->
            <_referenceAssemblyPaths Include="@(_projectReferenceCopyLocalPaths->WithMetadataValue('Extension', '.dll')->WithMetadataValue('IncludeReferenceAssemblyInPackage', 'true')->Metadata('ReferenceAssembly'))" />
            <_referenceAssemblyPaths Include="@(_projectReferenceCopyLocalPaths->WithMetadataValue('Extension', '.xml')->WithMetadataValue('IncludeReferenceAssemblyInPackage', 'true'))" />
            <TfmSpecificPackageFile Include="@(_referenceAssemblyPaths)" PackagePath="ref/$(TargetFramework)" />
        </ItemGroup>
    </Target>

    <Target Name="ValidateAssemblyVersionsInRefPack" Condition="$(_AssemblyInTargetingPack) == 'true' and '$(PreReleaseVersionLabel)' == 'servicing'" AfterTargets="CoreCompile">
        <Error Condition="'$(AssemblyVersion)' != '$(LastReleasedStableAssemblyVersion)'" Text="AssemblyVersion should match last released assembly version $(LastReleasedStableAssemblyVersion)" />
    </Target>

</Project>
